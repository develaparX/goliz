package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"os"
	
	"strings"
	"sync"
	"time"

	"github.com/joho/godotenv"
	"google.golang.org/genai"
	tele "gopkg.in/telebot.v3"
)

// === Enums & State ===
type AnalysisMode int

const (
	ModeStandard AnalysisMode = iota // /analyst
	ModeScalping                     // /analyst-scalping
)

var (
	// userMode stores the user's selected mode
	userMode sync.Map // map[int64]AnalysisMode
	
	// albumBuffer stores photos from a media group
	// map[string]*AlbumData (key: MediaGroupID)
	albumBuffer sync.Map
)

type AlbumData struct {
	CapturedAt time.Time
	Photos     [][]byte
	Caption    string
	UserID     int64
	Timer      *time.Timer
}

// === Prompts ===

func GeneratePrompt(mode AnalysisMode, assetName string, isMultiImage bool) string {
	baseRole := ""
	strategy := ""
	outputFocus := ""

	// 1. Determine Mdoe
	switch mode {
	case ModeScalping:
		baseRole = `ROLE: Kamu adalah "Antigravity Scalper", trader agresif spesialis timeframe kecil (M1, M5, M15). Kamu mencari momentum cepat, liquidity grabs, dan rejection tajam.`
		strategy = `METODE SCALPING (FAST EXECUTION):
- Fokus cari: Liquidity Sweep (Pengambilan Stoploss retail) lalu Reversal.
- Rejection Candle Wajib Jelas (Pinbar/Engulfing).
- Risk Reward Ratio minimal 1:2.
- Stoploss harus KETAT (Tight).`
		outputFocus = `## ‚ö°Ô∏è SCALPING SIGNAL (M1/M5)
- **ACTION:** (BUY NOW / SELL NOW / WAIT)
- **ENTRY AREA:** (Angka/Area)
- **SL (KETAT):** (Wajib max 10-20 pips untuk Gold, atau sesuaikan)
- **TP 1:** (Scalping Target)
- **TP 2:** (Runner)`

	default: // ModeStandard
		baseRole = `ROLE: Kamu adalah "Antigravity Quant Analyst", AI trading swing/intraday yang mencari setup High Probability (Win Rate > 80%). Kamu sabar dan hanya ambil setup A+.`
		strategy = `METODE STANDARD (SWING/INTRADAY):
- Gunakan Smart Money Concept (SMC) + Supply Demand.
- Validasi Market Structure (BOS/ChoCh).
- Cari konfirmasi Divergence atau Pola Chart Pattern.`
		outputFocus = `## üîÆ KEPUTUSAN FINAL (WIN RATE > 80%)
- **STATUS:** (STRONG BUY / STRONG SELL / WAIT & SEE)
- **ENTRY:** (Titik Pantul Ideal)
- **STOP LOSS:** (Swing Low/High Terakhir - Aman)
- **TAKE PROFIT:** (Liquidity Pool berikutnya)`
	}

	// 2. Multi-Image Context (Top Down)
	multiContext := ""
	if isMultiImage {
		multiContext = `
[MULTIPLE CHARTS DETECTED - TOP DOWN ANALYSIS MODE]
User mengirimkan LEBIH DARI 1 GAMBAR. Ini adalah analisa Multi-Timeframe.
1. Analisa gambar Timeframe BESAR dulu untuk Trend Bias (Bullish/Bearish).
2. Analisa gambar Timeframe KECIL untuk mencari Entry Point presisi.
3. Pastikan Bias HTF dan LTF sejalan (Confluence). Jika bertabrakan, pilih "NO TRADE".`
	}

	// 3. Construct Full Prompt (Visual Enhancement)
	return fmt.Sprintf(`
%s

CONTEXT:
User mengirimkan chart trading.
Nama Aset: %s
%s

TUGAS EKSEKUSI:

LANGKAH 1: EXTERNAL DATA VALIDATION (Google Search)
- Cari sentimen pasar %s hari ini (Bullish/Bearish).

LANGKAH 2: VISUAL ANALYSIS
%s
--------------------------------------------------------
‚ö†Ô∏è CRITICAL RULE:
1. JANGAN MENERKA ANGKA. Jika buram, gunakan deskripsi visual (e.g. "Below low").
2. Jika ada multi-chart, gabungkan analisanya menjadi satu kesimpulan padu.
--------------------------------------------------------

LANGKAH 3: FINAL CHECK
- Setup valid hanya jika Sentimen Web mendukung Analisa Visual.

OUTPUT FORMAT (Markdown Telegram - Visual Aesthetics):

# üõ∏ **ANTIGRAVITY %s** 
`+"`%s`"+`

---
## üß† **ANALYSIS BRIEF**
> _"Quote singkat insight utama kamu tentang chart ini."_

(Analisa padat visual chart & struktur market. Jika Top-Down, jelaskan alur HTF ke LTF.)

---
## üì° **INTELLIGENCE (WEB)**
| Data | Status |
| :--- | :--- |
| **Sentiment** | **[BULLISH/BEARISH]** |
| **Volatilitas**| (Tinggi/Rendah) |

---
## üéØ **MAPPING & LEVELS**
*Gunakan visual description jika angka tidak jelas.*

üíé **KEY ZONES:**
‚Ä¢ üü¶ **BUY:** (Area / Deskripsi)
‚Ä¢ üü• **SELL:** (Area / Deskripsi)
‚Ä¢ üöß **BREAKOUT:** (Level Validasi)

---
%s

---
_Generated by Antigravity AI Engine_
	`, baseRole, assetName, multiContext, assetName, strategy, getModeName(mode), assetName, outputFocus)
}

func getModeName(m AnalysisMode) string {
	if m == ModeScalping {
		return "SCALPING CAFE"
	}
	return "STANDARD LABS"
}

func main() {
	// Load .env
	_ = godotenv.Load()

	// 1. Init Bot
	pref := tele.Settings{
		Token:  os.Getenv("TELEGRAM_BOT_TOKEN"),
		Poller: &tele.LongPoller{Timeout: 10 * time.Second},
	}

	b, err := tele.NewBot(pref)
	if err != nil {
		log.Fatal(err)
	}

	// 2. Init Gemini
	ctx := context.Background()
	client, err := genai.NewClient(ctx, &genai.ClientConfig{
		APIKey: os.Getenv("GEMINI_API_KEY"),
	})
	if err != nil {
		log.Fatal(err)
	}

	// === Commands ===
	
	// /analyst - Set standard mode
	b.Handle("/analyst", func(c tele.Context) error {
		userMode.Store(c.Sender().ID, ModeStandard)
		return c.Send("üõ∏ **Mode: ANALYST STANDARD ACTIVATED**\n\nSilakan kirimkan chart Anda (Single atau Album untuk Top Down Analysis).\nJangan lupa tulis nama aset di caption!", tele.ModeMarkdown)
	})

	// /analyst-scalping - Set scalping mode
	b.Handle("/scalping", func(c tele.Context) error { // shortened for ease
		userMode.Store(c.Sender().ID, ModeScalping)
		return c.Send("‚ö°Ô∏è **Mode: SCALPER ELITE ACTIVATED**\n\nKirim chart Timeframe Kecil (M1/M5). Sinyal akan fokus pada entry cepat & tight SL.", tele.ModeMarkdown)
	})
	// Handle full command name too just in case
	b.Handle("/analyst-scalping", func(c tele.Context) error {
		userMode.Store(c.Sender().ID, ModeScalping)
		return c.Send("‚ö°Ô∏è **Mode: SCALPER ELITE ACTIVATED**\n\nKirim chart Timeframe Kecil (M1/M5). Sinyal akan fokus pada entry cepat & tight SL.", tele.ModeMarkdown)
	})


	// === Helper: Process Logic ===
	processAnalysis := func(userID int64, caption string, images [][]byte, chat *tele.Chat) {
		// 1. Determine Mode
		mode := ModeStandard
		if val, ok := userMode.Load(userID); ok {
			mode = val.(AnalysisMode)
		}

		// 2. Default Caption Check
		targetAsset := caption
		if targetAsset == "" {
			targetAsset = "Unknown Asset"
			// Try to infer from "analyst XAUUSD" pattern if user typed command in caption previously?
			// For now require caption.
		}

		// 3. Status Update
		statusText := "‚è≥ *Processing Single Chart...*"
		if len(images) > 1 {
			statusText = fmt.Sprintf("‚è≥ *Processing Top-Down Analysis (%d Charts)...*", len(images))
		}
		statusMsg, _ := b.Send(chat, statusText, tele.ModeMarkdown)

		// 4. Prepare Gemini Parts
		parts := []*genai.Part{}
		
		// Add Prompt first
		prompt := GeneratePrompt(mode, targetAsset, len(images) > 1)
		parts = append(parts, genai.NewPartFromText(prompt))

		// Add All Images
		for _, img := range images {
			parts = append(parts, genai.NewPartFromBytes(img, "image/jpeg"))
		}

		// 5. Build Request
		contents := []*genai.Content{{Parts: parts, Role: "user"}}
		
		// Tools
		tools := []*genai.Tool{{GoogleSearch: &genai.GoogleSearch{}}}
		
		config := &genai.GenerateContentConfig{
			Tools: tools,
		}

		// 6. Call Gemini
		// Using gemini-flash-latest for quota safety
		resp, err := client.Models.GenerateContent(ctx, "gemini-flash-latest", contents, config)
		
		if statusMsg != nil {
			b.Delete(statusMsg)
		}

		if err != nil {
			log.Printf("Gemini Error: %v", err)
			b.Send(chat, "‚ö†Ô∏è Error analyzing (Quota or API Issue). Try again later.")
			return
		}

		if resp == nil || len(resp.Candidates) == 0 {
			b.Send(chat, "‚ö†Ô∏è No response from AI.")
			return
		}

		// 7. Send Result
		responseText := ""
		for _, part := range resp.Candidates[0].Content.Parts {
			responseText += part.Text
		}
		b.Send(chat, responseText, tele.ModeMarkdown)
	}


	// === Photo Handler (with Album Support) ===
	b.Handle(tele.OnPhoto, func(c tele.Context) error {
		photo := c.Message().Photo
		caption := c.Message().Caption
		
		// If caption is a command, switch mode immediately (optional UX improvement)
		if strings.HasPrefix(caption, "/scalping") {
			userMode.Store(c.Sender().ID, ModeScalping)
		} else if strings.HasPrefix(caption, "/analyst") {
			userMode.Store(c.Sender().ID, ModeStandard)
		}

		// Download Photo
		rc, err := b.File(&photo.File)
		if err != nil {
			return err
		}
		imgData, err := io.ReadAll(rc)
		rc.Close()
		if err != nil {
			return err
		}

		mediaGroupID := c.Message().AlbumID
		userID := c.Sender().ID

		// CASE A: Single Photo (No Media Group)
		if mediaGroupID == "" {
			// Require caption for single photo usually, or use previous context?
			// Let's enforce caption if possible, or default to "Analysis".
			finalCaption := caption
			if finalCaption == "" {
				return c.Send("‚õîÔ∏è Please write the Asset Name in the caption.")
			}
			
			go processAnalysis(userID, finalCaption, [][]byte{imgData}, c.Chat())
			return nil
		}

		// CASE B: Album (Batched)
		// Logic: Store in map, reset timer. If timer hits, process.
		
		actualData, _ := albumBuffer.LoadOrStore(mediaGroupID, &AlbumData{
			UserID: userID,
			Photos: [][]byte{},
			Timer:  nil,
		})
		data := actualData.(*AlbumData)

		// Append photo
		data.Photos = append(data.Photos, imgData)
		
		// Take the caption from the first message that has it
		if caption != "" && data.Caption == "" {
			data.Caption = caption
		}

		// Reset Timer
		if data.Timer != nil {
			data.Timer.Stop()
		}
		
		// Wait 2 seconds for other photos
		data.Timer = time.AfterFunc(2*time.Second, func() {
			// Clean up map
			albumBuffer.Delete(mediaGroupID)
			
			// Validate Caption
			if data.Caption == "" {
				b.Send(c.Chat(), "‚ö†Ô∏è Album received but NO CAPTION found. Processing as 'General Market Analysis'...")
				data.Caption = "Market Analysis"
			}
			
			// Process
			// Sort/Order? Telegram usually delivers in order, but not guaranteed.
			// Vision model is generally robust enough to figure out HTF vs LTF contextually or we prompt it.
			processAnalysis(data.UserID, data.Caption, data.Photos, c.Chat())
		})

		return nil
	})

	fmt.Println("üöÄ Antigravity Bot (Multi-Mode) Started...")
	b.Start()
}