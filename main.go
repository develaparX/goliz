package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net/url"
	"os"

	"strings"
	"sync"
	"time"

	"github.com/joho/godotenv"
	"google.golang.org/genai"
	tele "gopkg.in/telebot.v3"
)

// === Enums & State ===
type AnalysisMode int

const (
	ModeStandard     AnalysisMode = iota // /analyst
	ModeScalping                         // /analyst-scalping
	ModeAutoScalping                     // /autosc - auto fetch charts for scalping
	ModeAutoSwing                        // /autosw - auto fetch charts for swing
	ModeAutoIntraday                     // /autoint - auto fetch charts for intraday
)

var (
	// userMode stores the user's selected mode
	userMode sync.Map // map[int64]AnalysisMode
	
	// albumBuffer stores photos from a media group
	// map[string]*AlbumData (key: MediaGroupID)
	albumBuffer sync.Map
)

type AlbumData struct {
	Mu         sync.Mutex
	CapturedAt time.Time
	Photos     [][]byte
	Caption    string
	UserID     int64
	Timer      *time.Timer
	Generation int
}

// === Prompts ===

func GeneratePrompt(mode AnalysisMode, assetName string, isMultiImage bool) string {
	baseRole := ""
	strategy := ""

	// 1. Determine Mdoe
	switch mode {
	case ModeScalping:
		baseRole = `ROLE: Kamu adalah "Antigravity Scalper", trader agresif spesialis timeframe kecil (M1, M5, M15). Kamu mencari momentum cepat, liquidity grabs, dan rejection tajam.`
		strategy = `METODE SCALPING (FAST EXECUTION):
- Fokus cari: Liquidity Sweep (Pengambilan Stoploss retail) lalu Reversal.
- Rejection Candle Wajib Jelas (Pinbar/Engulfing).
- Risk Reward Ratio minimal 1:2.
- Stoploss harus KETAT (Tight).`

	default: // ModeStandard
		baseRole = `ROLE: Kamu adalah "Antigravity Quant Analyst", AI trading swing/intraday yang mencari setup High Probability (Win Rate > 80%). Kamu sabar dan hanya ambil setup A+.`
		strategy = `METODE STANDARD (SWING/INTRADAY):
- Gunakan Smart Money Concept (SMC) + Supply Demand.
- Validasi Market Structure (BOS/ChoCh).
- Cari konfirmasi Divergence atau Pola Chart Pattern.`
	}

	// 2. Multi-Image Context (Top Down)
	multiContext := ""
	if isMultiImage {
		multiContext = `
[MULTIPLE CHARTS DETECTED - TOP DOWN ANALYSIS MODE]
User mengirimkan LEBIH DARI 1 GAMBAR. Ini adalah analisa Multi-Timeframe.
1. Analisa gambar Timeframe BESAR dulu untuk Trend Bias (Bullish/Bearish).
2. Analisa gambar Timeframe KECIL untuk mencari Entry Point presisi.
3. Pastikan Bias HTF dan LTF sejalan (Confluence). Jika bertabrakan, pilih "NO TRADE".`
	}



	// 3. Construct Full Prompt (Visual Enhancement)
	return fmt.Sprintf(`
%s

CONTEXT:
User mengirimkan chart trading.
Nama Aset: %s
%s

TUGAS EKSEKUSI:

LANGKAH 0: IMAGE CLARITY CHECK üîç
- Periksa visual chart. JIKA BURAM / TIDAK TERBACA: HENTIKAN ANALISA.
- Output: "‚ö†Ô∏è <b>GAMBAR TIDAK JELAS</b>"

LANGKAH 1: EXTERNAL DATA VALIDATION
- Cari sentimen pasar %s hari ini.

LANGKAH 2: VISUAL ANALYSIS
%s
--------------------------------------------------------
CRITICAL RULE:
1. GUNAKAN FORMAT HTML (Telegram Compatible).
2. Escape karakter < > & di dalam teks biasa.
3. GUNAKAN Code Block "diff" untuk warna merah/hijau.
--------------------------------------------------------

OUTPUT FORMAT (STRICT HTML):


<b>üõ∏ ANTIGRAVITY PRIME</b>
<code>%s</code> ‚Ä¢ <code>%s</code>

<b>‚öôÔ∏è STRATEGY MODE: %s</b>

<blockquote>üí° <i>"Quote insight singkat tentang setup ini."</i></blockquote>

<b>üìä SMART DATA</b>
Sentiment: <b>[BULLISH/BEARISH]</b>
Volatilitas: [Low/Med/High]

<b>üíé SIGNAL CARD</b>
<pre><code class="language-diff">
[Gunakan tanda + untuk HIJAU (Buy/TP/Positif)]
[Gunakan tanda - untuk MERAH (Sell/SL/Negatif)]
[Contoh format:]
+ ACTION:  BUY NOW
+ ENTRY:   2030.50
- SL:      2025.00
+ TP 1:    2035.00
+ TP 2:    2040.00
</code></pre>

<b>üìù ANALYSIS BRIEF</b>
(Jelaskan alasan teknikal & fundamental secara padat.)

<b>‚ö†Ô∏è RISK NOTES</b>
(Saran risk management.)

---
<i>Generated by Antigravity AI</i>
	`, baseRole, assetName, multiContext, assetName, strategy, getModeName(mode), assetName, getModeName(mode))
}

func getModeName(m AnalysisMode) string {
	switch m {
	case ModeScalping, ModeAutoScalping:
		return "SCALPING CAFE"
	case ModeAutoSwing:
		return "SWING MASTER"
	case ModeAutoIntraday:
		return "INTRADAY PRO"
	default:
		return "STANDARD LABS"
	}
}

func main() {
	// Load .env
	_ = godotenv.Load()

	// 1. Init Bot
	pref := tele.Settings{
		Token:  os.Getenv("TELEGRAM_BOT_TOKEN"),
		Poller: &tele.LongPoller{Timeout: 10 * time.Second},
	}

	b, err := tele.NewBot(pref)
	if err != nil {
		log.Fatal(err)
	}

	// 2. Init Gemini
	ctx := context.Background()
	client, err := genai.NewClient(ctx, &genai.ClientConfig{
		APIKey: os.Getenv("GEMINI_API_KEY"),
	})
	if err != nil {
		log.Fatal(err)
	}

	// === Commands ===
	var handlePhoto func(c tele.Context) error
	
	// Middleware: Log all incoming messages for debugging
	b.Use(func(next tele.HandlerFunc) tele.HandlerFunc {
		return func(c tele.Context) error {
			if c.Message() != nil {
				log.Printf("üì® [INCOMING] From: %d | Text: '%s' | HasPhoto: %v", 
					c.Sender().ID, 
					c.Message().Text, 
					c.Message().Photo != nil)
			}
			return next(c)
		}
	})
	
	// /analyst - Set standard mode
	b.Handle("/analyst", func(c tele.Context) error {
		log.Printf("üî• [HANDLER] /analyst triggered by user %d", c.Sender().ID)
		userMode.Store(c.Sender().ID, ModeStandard)
		if c.Message().Photo != nil {
			return handlePhoto(c)
		}
		return c.Send("üõ∏ <b>Mode: ANALYST STANDARD ACTIVATED</b>\n\nSilakan kirimkan chart Anda (Single atau Album untuk Top Down Analysis).\nJangan lupa tulis nama aset di caption!", tele.ModeHTML)
	})

	// /analyst-scalping - Set scalping mode
	b.Handle("/scalping", func(c tele.Context) error { // shortened for ease
		log.Printf("üî• [HANDLER] /scalping triggered by user %d", c.Sender().ID)
		userMode.Store(c.Sender().ID, ModeScalping)
		if c.Message().Photo != nil {
			return handlePhoto(c)
		}
		return c.Send("‚ö°Ô∏è <b>Mode: SCALPER ELITE ACTIVATED</b>\n\nKirim chart Timeframe Kecil (M1/M5). Sinyal akan fokus pada entry cepat & tight SL.", tele.ModeHTML)
	})
	// Handle full command name too just in case
	b.Handle("/analyst-scalping", func(c tele.Context) error {
		log.Printf("üî• [HANDLER] /analyst-scalping triggered by user %d", c.Sender().ID)
		userMode.Store(c.Sender().ID, ModeScalping)
		if c.Message().Photo != nil {
			return handlePhoto(c)
		}
		return c.Send("‚ö°Ô∏è <b>Mode: SCALPER ELITE ACTIVATED</b>\n\nKirim chart Timeframe Kecil (M1/M5). Sinyal akan fokus pada entry cepat & tight SL.", tele.ModeHTML)
	})

	// /help - Show usage instructions
	helpHandler := func(c tele.Context) error {
		log.Printf("üî• [HANDLER] /help or /start triggered by user %d", c.Sender().ID)
		helpText := `ü§ñ <b>ANTIGRAVITY AI BOT</b> ü§ñ
		
Selamat datang! Saya adalah asisten trading AI Anda.

<b>üìö CARA PENGGUNAAN:</b>

<b>1. Mode Manual (Kirim Screenshot):</b>
   ‚Ä¢ /analyst - <b>Mode Standard</b> (Swing/Intraday)
   ‚Ä¢ /scalping - <b>Mode Scalping</b> (M1/M5)
   
<b>2. Mode Auto (Binance Chart):</b>
   ‚Ä¢ /autosc BTCUSDT - <b>Auto Scalping</b> (5m,15m,1H,4H,1D)
   ‚Ä¢ /autosw BTCUSDT - <b>Auto Swing</b> (5m,15m,1H,4H,1D,1W)
   ‚Ä¢ /autoint BTCUSDT - <b>Auto Intraday</b> (5m,15m,1H,4H,1D,1W)

<b>3. Kirim Chart Manual:</b>
   ‚Ä¢ Kirim <b>GAMBAR</b> chart Anda
   ‚Ä¢ <b>WAJIB</b> tulis nama aset di caption
   ‚Ä¢ <b>Top-Down Analysis</b>: Kirim beberapa gambar sekaligus (Album)

<b>üí° Contoh Auto Mode:</b>
<code>/autosc ETHUSDT</code> - Scalping analysis untuk Ethereum
<code>/autosw BTCUSDT</code> - Swing analysis untuk Bitcoin

<b>üöÄ Mulai sekarang!</b>`
		return c.Send(helpText, tele.ModeHTML)
	}
	
	b.Handle("/help", helpHandler)
	b.Handle("/start", helpHandler)


	// === Helper: Process Logic ===
	processAnalysis := func(userID int64, caption string, images [][]byte, chat *tele.Chat) {
		// 1. Determine Mode
		mode := ModeStandard
		if val, ok := userMode.Load(userID); ok {
			mode = val.(AnalysisMode)
		}

		// 2. Default Caption Check
		targetAsset := caption
		
		// Strip command if present (e.g. "/scalping XAUUSD" -> "XAUUSD")
		if strings.HasPrefix(targetAsset, "/") {
			parts := strings.SplitN(targetAsset, " ", 2)
			if len(parts) > 1 {
				targetAsset = parts[1]
			} else {
				targetAsset = "" // Command only, no asset name
			}
		}

		if targetAsset == "" {
			targetAsset = "Unknown Asset"
			// Try to infer from "analyst XAUUSD" pattern if user typed command in caption previously?
			// For now require caption.
		}


		// 3. Status Update
		strategyName := getModeName(mode)
		statusText := fmt.Sprintf("‚è≥ <i>Processing Single Chart...</i>\n‚öôÔ∏è <b>Strategy: %s</b>", strategyName)
		if len(images) > 1 {
			statusText = fmt.Sprintf("‚è≥ <i>Processing Top-Down Analysis (%d Charts)...</i>\n‚öôÔ∏è <b>Strategy: %s</b>", len(images), strategyName)
		}
		statusMsg, err := b.Send(chat, statusText, tele.ModeHTML)

		if err != nil {
			log.Printf("‚ùå [TELEGRAM] Failed to send STATUS to %d: %v", chat.ID, err)
		} else {
			log.Printf("‚úÖ [TELEGRAM] Status sent to %d", chat.ID)
		}

		// 4. Prepare Gemini Parts
		parts := []*genai.Part{}
		
		// Add Prompt first
		prompt := GeneratePrompt(mode, targetAsset, len(images) > 1)
		parts = append(parts, genai.NewPartFromText(prompt))

		// Add All Images
		for _, img := range images {
			parts = append(parts, genai.NewPartFromBytes(img, "image/jpeg"))
		}

		// 5. Build Request
		contents := []*genai.Content{{Parts: parts, Role: "user"}}
		
		// Tools
		tools := []*genai.Tool{{GoogleSearch: &genai.GoogleSearch{}}}
		
		config := &genai.GenerateContentConfig{
			Tools: tools,
		}

		// 6. Call Gemini
		// Using gemini-flash-latest for quota safety
		resp, err := client.Models.GenerateContent(ctx, "gemini-flash-latest", contents, config)
		
		if statusMsg != nil {
			b.Delete(statusMsg)
		}

		if err != nil {
			log.Printf("‚ùå [GEMINI] API Error: %v", err)
			_, errSend := b.Send(chat, "‚ö†Ô∏è <b>Error analyzing</b> (Quota or API Issue). Try again later.", tele.ModeHTML)
			if errSend != nil {
				log.Printf("‚ùå [TELEGRAM] Failed to send ERROR notification to %d: %v", chat.ID, errSend)
			}
			return
		}

		if resp == nil || len(resp.Candidates) == 0 {
			_, errSend := b.Send(chat, "‚ö†Ô∏è No response from AI.", tele.ModeHTML)
			if errSend != nil {
				log.Printf("‚ùå [TELEGRAM] Failed to send NO RESPONSE notification to %d: %v", chat.ID, errSend)
			}
			return
		}

		// 7. Send Result
		responseText := ""
		for _, part := range resp.Candidates[0].Content.Parts {
			responseText += part.Text
		}
		
		// Clean / Fix Gemini MD output to valid HTML
		responseText = cleanHTML(responseText)

		msg, err := b.Send(chat, responseText, &tele.SendOptions{
			ParseMode: tele.ModeHTML,
			ReplyMarkup: &tele.ReplyMarkup{
				InlineKeyboard: [][]tele.InlineButton{
					{
						{
							Text: "üìà TradingView",
							URL:  fmt.Sprintf("https://www.tradingview.com/chart/?symbol=%s", strings.ToUpper(strings.ReplaceAll(targetAsset, " ", ""))),
						},
						{
							Text: "üì∞ News",
							URL:  fmt.Sprintf("https://www.google.com/search?q=%s+news", url.QueryEscape(targetAsset)),
						},
					},
					{
						{
							Text:   "‚ö†Ô∏è Disclaimer",
							Unique: "disclaimer_btn",
						},
					},
				},
			},
		})
		if err != nil {
			log.Printf("‚ùå [TELEGRAM] Failed to send FINAL ANALYSIS to %d: %v", chat.ID, err)
		} else {
			log.Printf("‚úÖ [TELEGRAM] Analysis sent to %d (MsgID: %d)", chat.ID, msg.ID)
		}
	}

	// === Auto Trading Command Handlers ===
	
	// Helper function to process auto chart analysis (DATA-BASED - no images)
	processAutoChart := func(c tele.Context, tradingMode TradingMode, analysisMode AnalysisMode) error {
		log.Printf("üì• [AUTO-DATA] Command received: mode=%s", tradingMode)
		
		// Parse symbol from command arguments
		args := c.Args()
		if len(args) == 0 {
			log.Printf("‚ö†Ô∏è [AUTO-DATA] No symbol provided")
			return c.Send("‚ö†Ô∏è <b>Mohon masukkan simbol trading!</b>\n\nContoh: <code>/autosc BTCUSDT</code>", tele.ModeHTML)
		}
		
		symbol := strings.ToUpper(args[0])
		userID := c.Sender().ID
		chat := c.Chat()
		
		log.Printf("üìä [AUTO-DATA] Processing symbol: %s for user: %d", symbol, userID)
		
		// Store mode
		userMode.Store(userID, analysisMode)
		
		// Send initial status
		modeName := getModeName(analysisMode)
		timeframes := GetTimeframesForMode(tradingMode)
		tfList := ""
		for i, tf := range timeframes {
			if i > 0 {
				tfList += ", "
			}
			tfList += string(tf)
		}
		
		log.Printf("‚è∞ [AUTO-DATA] Timeframes to fetch: %s", tfList)
		
		statusMsg, sendErr := b.Send(chat, fmt.Sprintf(`‚è≥ <b>FETCHING DATA...</b>

üìä <b>Symbol:</b> %s
‚öôÔ∏è <b>Mode:</b> %s
üïê <b>Timeframes:</b> %s
üìà <b>Candles:</b> 200 per timeframe

<i>Mengambil data dari Binance...</i>`, symbol, modeName, tfList), tele.ModeHTML)
		
		if sendErr != nil {
			log.Printf("‚ùå [AUTO-DATA] Failed to send status message: %v", sendErr)
		} else {
			log.Printf("‚úÖ [AUTO-DATA] Status message sent")
		}
		
		// Run in goroutine to not block
		go func() {
			log.Printf("üîÑ [AUTO-DATA] Starting goroutine for %s", symbol)
			
			// Fetch multi-timeframe data (200 candles for context)
			log.Printf("üìà [AUTO-DATA] Fetching candlestick data...")
			summaries, err := FetchMultiTimeframeData(symbol, tradingMode, 200)
			if err != nil {
				log.Printf("‚ùå [AUTO-DATA] Error fetching data: %v", err)
				if statusMsg != nil {
					b.Delete(statusMsg)
				}
				b.Send(chat, fmt.Sprintf("‚ùå <b>Error fetching data:</b> %s\n\n<i>Pastikan symbol benar (contoh: BTCUSDT) dan koneksi internet stabil.</i>", err.Error()), tele.ModeHTML)
				return
			}
			log.Printf("‚úÖ [AUTO-DATA] Fetched data for %d timeframes", len(summaries))
			
			// Log summary for each timeframe
			for _, s := range summaries {
				log.Printf("üìã [AUTO-DATA] %s: Trend=%s, RSI=%.1f, Change=%.2f%%", 
					GetTimeframeName(s.Interval), s.Trend, s.RSI, s.PriceChange)
			}
			
			// Update status
			if statusMsg != nil {
				b.Edit(statusMsg, fmt.Sprintf(`‚úÖ <b>DATA FETCHED!</b>

üìä <b>Symbol:</b> %s
üìà <b>Timeframes:</b> %d
ü§ñ <b>Status:</b> Analyzing with AI...`, symbol, len(summaries)), tele.ModeHTML)
			}
			
			// Format data for AI
			dataContext := FormatDataForAI(symbol, summaries, tradingMode)
			log.Printf("üìù [AUTO-DATA] Data formatted for AI (%d bytes)", len(dataContext))
			
			// Generate specialized prompt for data analysis
			prompt := GenerateDataAnalysisPrompt(tradingMode, symbol, dataContext)
			
			// Build Gemini request (text only, no images!)
			parts := []*genai.Part{genai.NewPartFromText(prompt)}
			contents := []*genai.Content{{Parts: parts, Role: "user"}}
			
			// Tools (Google Search for sentiment)
			tools := []*genai.Tool{{GoogleSearch: &genai.GoogleSearch{}}}
			config := &genai.GenerateContentConfig{Tools: tools}
			
			// Call Gemini
			log.Printf("ü§ñ [AUTO-DATA] Calling Gemini AI...")
			resp, err := client.Models.GenerateContent(ctx, "gemini-2.0-flash", contents, config)
			
			// Delete status message
			if statusMsg != nil {
				b.Delete(statusMsg)
			}
			
			if err != nil {
				log.Printf("‚ùå [AUTO-DATA] Gemini API Error: %v", err)
				b.Send(chat, "‚ö†Ô∏è <b>Error analyzing</b> (Quota or API Issue). Try again later.", tele.ModeHTML)
				return
			}
			
			if resp == nil || len(resp.Candidates) == 0 {
				log.Printf("‚ùå [AUTO-DATA] Empty response from Gemini")
				b.Send(chat, "‚ö†Ô∏è No response from AI.", tele.ModeHTML)
				return
			}
			
			// Extract response text
			responseText := ""
			for _, part := range resp.Candidates[0].Content.Parts {
				responseText += part.Text
			}
			
			// Clean HTML
			responseText = cleanHTML(responseText)
			log.Printf("‚úÖ [AUTO-DATA] Analysis received (%d chars)", len(responseText))
			
			// Send result with inline buttons
			msg, err := b.Send(chat, responseText, &tele.SendOptions{
				ParseMode: tele.ModeHTML,
				ReplyMarkup: &tele.ReplyMarkup{
					InlineKeyboard: [][]tele.InlineButton{
						{
							{
								Text: "üìà TradingView",
								URL:  fmt.Sprintf("https://www.tradingview.com/chart/?symbol=BINANCE:%s", symbol),
							},
							{
								Text: "üì∞ News",
								URL:  fmt.Sprintf("https://www.google.com/search?q=%s+crypto+news", symbol),
							},
						},
						{
							{
								Text:   "‚ö†Ô∏è Disclaimer",
								Unique: "disclaimer_btn",
							},
						},
					},
				},
			})
			
			if err != nil {
				log.Printf("‚ùå [AUTO-DATA] Failed to send analysis: %v", err)
			} else {
				log.Printf("‚úÖ [AUTO-DATA] Analysis sent (MsgID: %d)", msg.ID)
			}
		}()
		
		log.Printf("‚è≥ [AUTO-DATA] Goroutine started, returning immediately")
		return nil
	}
	
	// /autosc - Auto Scalping
	b.Handle("/autosc", func(c tele.Context) error {
		log.Printf("üî• [HANDLER] /autosc triggered by user %d", c.Sender().ID)
		return processAutoChart(c, TradingModeScalping, ModeAutoScalping)
	})
	
	// /autosw - Auto Swing
	b.Handle("/autosw", func(c tele.Context) error {
		log.Printf("üî• [HANDLER] /autosw triggered by user %d", c.Sender().ID)
		return processAutoChart(c, TradingModeSwing, ModeAutoSwing)
	})
	
	// /autoint - Auto Intraday
	b.Handle("/autoint", func(c tele.Context) error {
		log.Printf("üî• [HANDLER] /autoint triggered by user %d", c.Sender().ID)
		return processAutoChart(c, TradingModeIntraday, ModeAutoIntraday)
	})


	// === Helper: Interactive Callbacks ===
	b.Handle(&tele.InlineButton{Unique: "disclaimer_btn"}, func(c tele.Context) error {
		return c.Respond(&tele.CallbackResponse{
			Text:      "‚ö†Ô∏è DISCLAIMER: Sinyal ini dihasilkan oleh AI (Artificial Intelligence). Tidak ada jaminan profit 100%. Gunakan money management yang bijak. Do Your Own Research (DYOR).",
			ShowAlert: true,
		})
	})



	// === Photo Handler (with Album Support) ===
	handlePhoto = func(c tele.Context) error {
		photo := c.Message().Photo
		caption := c.Message().Caption
		
		// If caption is a command, switch mode immediately (optional UX improvement)
		if strings.HasPrefix(caption, "/scalping") {
			userMode.Store(c.Sender().ID, ModeScalping)
		} else if strings.HasPrefix(caption, "/analyst") {
			userMode.Store(c.Sender().ID, ModeStandard)
		}

		// Download Photo
		rc, err := b.File(&photo.File)
		if err != nil {
			return err
		}
		imgData, err := io.ReadAll(rc)
		rc.Close()
		if err != nil {
			return err
		}

		mediaGroupID := c.Message().AlbumID
		userID := c.Sender().ID

		// CASE A: Single Photo (No Media Group)
		if mediaGroupID == "" {
			// Require caption for single photo usually, or use previous context?
			// Let's enforce caption if possible, or default to "Analysis".
			finalCaption := caption
			if finalCaption == "" {
				return c.Send("‚õîÔ∏è Please write the Asset Name in the caption.")
			}
			
			go processAnalysis(userID, finalCaption, [][]byte{imgData}, c.Chat())
			return nil
		}

		// CASE B: Album (Batched)
		// Logic: Store in map, reset timer. If timer hits, process.
		
		actualData, _ := albumBuffer.LoadOrStore(mediaGroupID, &AlbumData{
			UserID: userID,
			Photos: [][]byte{},
			Timer:  nil,
		})
		data := actualData.(*AlbumData)

		data.Mu.Lock()
		defer data.Mu.Unlock()

		// Append photo
		data.Photos = append(data.Photos, imgData)
		data.Generation++
		currentGen := data.Generation
		
		// Take the caption from the first message that has it
		if caption != "" && data.Caption == "" {
			data.Caption = caption
		}

		// Reset Timer
		if data.Timer != nil {
			data.Timer.Stop()
		}
		
		// Wait 4 seconds for other photos (handling slow internet)
		data.Timer = time.AfterFunc(4*time.Second, func() {
			data.Mu.Lock()
			
			// CONFIRMATION: Check if this timer is the latest generation
			if data.Generation != currentGen {
				data.Mu.Unlock()
				return
			}
			
			// Clean up map
			albumBuffer.Delete(mediaGroupID)
			
			// Capture data safely
			finalCaption := data.Caption
			finalPhotos := data.Photos
			
			data.Mu.Unlock()
			
			// Validate Caption
			if finalCaption == "" {
				b.Send(c.Chat(), "‚ö†Ô∏è Album received but NO CAPTION found. Processing as 'General Market Analysis'...")
				finalCaption = "Market Analysis"
			}
			
			// Process
			processAnalysis(userID, finalCaption, finalPhotos, c.Chat())
		})

		return nil
	}
	
	b.Handle(tele.OnPhoto, handlePhoto)

	log.Println("üìã [STARTUP] Registered handlers: /analyst, /scalping, /autosc, /autosw, /autoint, /help, /start")
	fmt.Println("üöÄ Antigravity Bot (Multi-Mode) Started...")
	b.Start()
}

func cleanHTML(text string) string {
	// 1. Convert Markdown Bold (**text**) to HTML Bold (<b>text</b>)
	countBold := strings.Count(text, "**")
	if countBold > 0 && countBold%2 == 0 {
		for i := 0; i < countBold/2; i++ {
			text = strings.Replace(text, "**", "<b>", 1)
			text = strings.Replace(text, "**", "</b>", 1)
		}
	} else {
		text = strings.ReplaceAll(text, "**", "")
	}
	
	// 2. Convert Markdown Italic (*text*) to HTML Italic (<i>text</i>)
	// Note: This is simpler/riskier but generally safe for Gemini output.
	countItalic := strings.Count(text, "*")
	if countItalic > 0 && countItalic%2 == 0 {
		for i := 0; i < countItalic/2; i++ {
			text = strings.Replace(text, "*", "<i>", 1)
			text = strings.Replace(text, "*", "</i>", 1)
		}
	}

	// 3. Escape standalone '&' which breaks Telegram HTML
	text = strings.ReplaceAll(text, " & ", " &amp; ")

	return text
}