package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net/url"
	"os"
	
	"strings"
	"sync"
	"time"

	"github.com/joho/godotenv"
	"google.golang.org/genai"
	tele "gopkg.in/telebot.v3"
)

// === Enums & State ===
type AnalysisMode int

const (
	ModeStandard AnalysisMode = iota // /analyst
	ModeScalping                     // /analyst-scalping
)

var (
	// userMode stores the user's selected mode
	userMode sync.Map // map[int64]AnalysisMode
	
	// albumBuffer stores photos from a media group
	// map[string]*AlbumData (key: MediaGroupID)
	albumBuffer sync.Map
)

type AlbumData struct {
	CapturedAt time.Time
	Photos     [][]byte
	Caption    string
	UserID     int64
	Timer      *time.Timer
}

// === Prompts ===

func GeneratePrompt(mode AnalysisMode, assetName string, isMultiImage bool) string {
	baseRole := ""
	strategy := ""
	outputFocus := ""

	// 1. Determine Mdoe
	switch mode {
	case ModeScalping:
		baseRole = `ROLE: Kamu adalah "Antigravity Scalper", trader agresif spesialis timeframe kecil (M1, M5, M15). Kamu mencari momentum cepat, liquidity grabs, dan rejection tajam.`
		strategy = `METODE SCALPING (FAST EXECUTION):
- Fokus cari: Liquidity Sweep (Pengambilan Stoploss retail) lalu Reversal.
- Rejection Candle Wajib Jelas (Pinbar/Engulfing).
- Risk Reward Ratio minimal 1:2.
- Stoploss harus KETAT (Tight).`
		outputFocus = `## ‚ö°Ô∏è SCALPING SIGNAL (M1/M5)
- **ACTION:** (BUY NOW / SELL NOW / WAIT)
- **ENTRY AREA:** (Angka/Area)
- **SL (KETAT):** (Wajib max 10-20 pips untuk Gold, atau sesuaikan)
- **TP 1:** (Scalping Target)
- **TP 2:** (Runner)`

	default: // ModeStandard
		baseRole = `ROLE: Kamu adalah "Antigravity Quant Analyst", AI trading swing/intraday yang mencari setup High Probability (Win Rate > 80%). Kamu sabar dan hanya ambil setup A+.`
		strategy = `METODE STANDARD (SWING/INTRADAY):
- Gunakan Smart Money Concept (SMC) + Supply Demand.
- Validasi Market Structure (BOS/ChoCh).
- Cari konfirmasi Divergence atau Pola Chart Pattern.`
		outputFocus = `## üîÆ KEPUTUSAN FINAL (WIN RATE > 80%)
- **STATUS:** (STRONG BUY / STRONG SELL / WAIT & SEE)
- **ENTRY:** (Titik Pantul Ideal)
- **STOP LOSS:** (Swing Low/High Terakhir - Aman)
- **TAKE PROFIT:** (Liquidity Pool berikutnya)`
	}

	// 2. Multi-Image Context (Top Down)
	multiContext := ""
	if isMultiImage {
		multiContext = `
[MULTIPLE CHARTS DETECTED - TOP DOWN ANALYSIS MODE]
User mengirimkan LEBIH DARI 1 GAMBAR. Ini adalah analisa Multi-Timeframe.
1. Analisa gambar Timeframe BESAR dulu untuk Trend Bias (Bullish/Bearish).
2. Analisa gambar Timeframe KECIL untuk mencari Entry Point presisi.
3. Pastikan Bias HTF dan LTF sejalan (Confluence). Jika bertabrakan, pilih "NO TRADE".`
	}


	// 3. Construct Full Prompt (Visual Enhancement)
	return fmt.Sprintf(`
%s

CONTEXT:
User mengirimkan chart trading.
Nama Aset: %s
%s

TUGAS EKSEKUSI:


LANGKAH 0: IMAGE CLARITY CHECK üîç
- Periksa visual chart. Apakah angka harga (kanan) dan bentuk candle terlihat JELAS?
- JIKA BURAM / TIDAK TERBACA: HENTIKAN ANALISA SEKARANG.
- Langsung output teks ini saja:
  "‚ö†Ô∏è **GAMBAR TIDAK JELAS / TERLALU BURAM** üå´Ô∏è
  
  Maaf, sistem tidak dapat membaca angka harga atau struktur candle secara presisi. Memaksakan analisa pada gambar buram sangat berbahaya.
  
  ‚úÖ **SOLUSI:**
  1. Kirim ulang gambar dengan opsi **'Send as File'** (agar tidak dikompres).
  2. Atau kirim screenshot yang lebih dekat (Zoom In) ke area kunci."

LANGKAH 1: EXTERNAL DATA VALIDATION (Google Search)
- (Lanjutkan hanya jika gambar JELAS)
- Cari sentimen pasar %s hari ini (Bullish/Bearish).

LANGKAH 2: VISUAL ANALYSIS
%s
--------------------------------------------------------
‚ö†Ô∏è CRITICAL RULE:
1. JANGAN MENERKA ANGKA. Jika buram, gunakan deskripsi visual (e.g. "Below low") ATAU tolak gambar sesuai Langkah 0.
2. Jika ada multi-chart, gabungkan analisanya menjadi satu kesimpulan padu.
--------------------------------------------------------

LANGKAH 3: FINAL CHECK
- Setup valid hanya jika Sentimen Web mendukung Analisa Visual.

OUTPUT FORMAT (STRICT TELEGRAM MARKDOWN V1):
Gunakan format di bawah ini persis. Jangan gunakan Markdown V2.
- Gunakan backtick tiga kali untuk blok kode.
- Gunakan backtick satu kali untuk highlight text.
- Gunakan *text* untuk tebal (JANGAN gunakan **text**).

--- FORMAT START ---
üõ∏ *ANTIGRAVITY PRIME* üõ∏
`+"`%s`"+` ‚Ä¢ `+"`%s`"+`

üß† *MARKET INTELLIGENCE*
> _"Quote insight singkat tentang setup ini."_

üìä *DATA FEED*
Sentiment: *[BULLISH/BEARISH]*
Volatilitas: [Low/Med/High]

üíé *SIGNAL CARD*
`+"```text"+`
SIDE:   [BUY / SELL / WAIT] 
ENTRY:  [Angka Entry Presisi]
SL:     [Angka Stop Loss]
TP 1:   [Target 1]
TP 2:   [Target 2]
`+"```"+`

üìù *ANALYSIS BRIEF*
(Jelaskan alasan teknikal & fundamental secara padat di sini. Gunakan poin-poin agar mudah dibaca.)

‚ö†Ô∏è *RISK NOTES*
(Saran risk management, misal: "Tunggu konfirmasi candle M5 close" atau "High Impact News in 30 mins").

---
_Generated by Antigravity AI_
--- FORMAT END ---
	`, baseRole, assetName, multiContext, assetName, strategy, getModeName(mode), assetName)
}

func getModeName(m AnalysisMode) string {
	if m == ModeScalping {
		return "SCALPING CAFE"
	}
	return "STANDARD LABS"
}

func main() {
	// Load .env
	_ = godotenv.Load()

	// 1. Init Bot
	pref := tele.Settings{
		Token:  os.Getenv("TELEGRAM_BOT_TOKEN"),
		Poller: &tele.LongPoller{Timeout: 10 * time.Second},
	}

	b, err := tele.NewBot(pref)
	if err != nil {
		log.Fatal(err)
	}

	// 2. Init Gemini
	ctx := context.Background()
	client, err := genai.NewClient(ctx, &genai.ClientConfig{
		APIKey: os.Getenv("GEMINI_API_KEY"),
	})
	if err != nil {
		log.Fatal(err)
	}

	// === Commands ===
	
	// /analyst - Set standard mode
	b.Handle("/analyst", func(c tele.Context) error {
		userMode.Store(c.Sender().ID, ModeStandard)
		return c.Send("üõ∏ **Mode: ANALYST STANDARD ACTIVATED**\n\nSilakan kirimkan chart Anda (Single atau Album untuk Top Down Analysis).\nJangan lupa tulis nama aset di caption!", tele.ModeMarkdown)
	})

	// /analyst-scalping - Set scalping mode
	b.Handle("/scalping", func(c tele.Context) error { // shortened for ease
		userMode.Store(c.Sender().ID, ModeScalping)
		return c.Send("‚ö°Ô∏è **Mode: SCALPER ELITE ACTIVATED**\n\nKirim chart Timeframe Kecil (M1/M5). Sinyal akan fokus pada entry cepat & tight SL.", tele.ModeMarkdown)
	})
	// Handle full command name too just in case
	b.Handle("/analyst-scalping", func(c tele.Context) error {
		userMode.Store(c.Sender().ID, ModeScalping)
		return c.Send("‚ö°Ô∏è **Mode: SCALPER ELITE ACTIVATED**\n\nKirim chart Timeframe Kecil (M1/M5). Sinyal akan fokus pada entry cepat & tight SL.", tele.ModeMarkdown)
	})

	// /help - Show usage instructions
	b.Handle({"/help", "/start"}, func(c tele.Context) error {
		helpText := `ü§ñ **ANTIGRAVITY AI BOT** ü§ñ
		
Selamat datang! Saya adalah asisten trading AI Anda.

**üìö CARA PENGGUNAAN:**

1. **Pilih Mode Analisa:**
   ‚Ä¢ /analyst - **Mode Standard** (Swing/Intraday). Mencari setup High Probability & SMC.
   ‚Ä¢ /scalping - **Mode Scalping** (M1/M5). Sinyal cepat, SL ketat, target pendek.

2. **Kirim Chart:**
   ‚Ä¢ Kirim **GAMBAR** chart Anda.
   ‚Ä¢ **WAJIB** tulis nama aset di caption (contoh: "XAUUSD", "BTCUSDT").
   ‚Ä¢ Jika gambar buram, kirim sebagai **FILE**.

3. **Fitur Tambahan:**
   ‚Ä¢ **Top-Down Analysis**: Kirim beberapa gambar sekaligus (Album). Bot akan menganalisa dari Timeframe besar ke kecil.

**üöÄ Mulai sekarang dengan memilih mode di atas!**`
		return c.Send(helpText, tele.ModeMarkdown)
	})


	// === Helper: Process Logic ===
	processAnalysis := func(userID int64, caption string, images [][]byte, chat *tele.Chat) {
		// 1. Determine Mode
		mode := ModeStandard
		if val, ok := userMode.Load(userID); ok {
			mode = val.(AnalysisMode)
		}

		// 2. Default Caption Check
		targetAsset := caption
		if targetAsset == "" {
			targetAsset = "Unknown Asset"
			// Try to infer from "analyst XAUUSD" pattern if user typed command in caption previously?
			// For now require caption.
		}

		// 3. Status Update
		statusText := "‚è≥ *Processing Single Chart...*"
		if len(images) > 1 {
			statusText = fmt.Sprintf("‚è≥ *Processing Top-Down Analysis (%d Charts)...*", len(images))
		}
		statusMsg, err := b.Send(chat, statusText, tele.ModeMarkdown)
		if err != nil {
			log.Printf("‚ùå [TELEGRAM] Failed to send STATUS to %d: %v", chat.ID, err)
		} else {
			log.Printf("‚úÖ [TELEGRAM] Status sent to %d", chat.ID)
		}

		// 4. Prepare Gemini Parts
		parts := []*genai.Part{}
		
		// Add Prompt first
		prompt := GeneratePrompt(mode, targetAsset, len(images) > 1)
		parts = append(parts, genai.NewPartFromText(prompt))

		// Add All Images
		for _, img := range images {
			parts = append(parts, genai.NewPartFromBytes(img, "image/jpeg"))
		}

		// 5. Build Request
		contents := []*genai.Content{{Parts: parts, Role: "user"}}
		
		// Tools
		tools := []*genai.Tool{{GoogleSearch: &genai.GoogleSearch{}}}
		
		config := &genai.GenerateContentConfig{
			Tools: tools,
		}

		// 6. Call Gemini
		// Using gemini-flash-latest for quota safety
		resp, err := client.Models.GenerateContent(ctx, "gemini-flash-latest", contents, config)
		
		if statusMsg != nil {
			b.Delete(statusMsg)
		}

		if err != nil {
			log.Printf("‚ùå [GEMINI] API Error: %v", err)
			_, errSend := b.Send(chat, "‚ö†Ô∏è Error analyzing (Quota or API Issue). Try again later.")
			if errSend != nil {
				log.Printf("‚ùå [TELEGRAM] Failed to send ERROR notification to %d: %v", chat.ID, errSend)
			}
			return
		}

		if resp == nil || len(resp.Candidates) == 0 {
			_, errSend := b.Send(chat, "‚ö†Ô∏è No response from AI.")
			if errSend != nil {
				log.Printf("‚ùå [TELEGRAM] Failed to send NO RESPONSE notification to %d: %v", chat.ID, errSend)
			}
			return
		}

		// 7. Send Result
		responseText := ""
		for _, part := range resp.Candidates[0].Content.Parts {
			responseText += part.Text
		}
		

		msg, err := b.Send(chat, responseText, tele.ModeMarkdown, &tele.SendOptions{
			ReplyMarkup: &tele.ReplyMarkup{
				InlineKeyboard: [][]tele.InlineButton{
					{
						{
							Text: "üìà TradingView",
							URL:  fmt.Sprintf("https://www.tradingview.com/chart/?symbol=%s", strings.ToUpper(strings.ReplaceAll(targetAsset, " ", ""))),
						},
						{
							Text: "üì∞ News",
							URL:  fmt.Sprintf("https://www.google.com/search?q=%s+news", url.QueryEscape(targetAsset)),
						},
					},
					{
						{
							Text:   "‚ö†Ô∏è Disclaimer",
							Unique: "disclaimer_btn",
						},
					},
				},
			},
		})
		if err != nil {
			log.Printf("‚ùå [TELEGRAM] Failed to send FINAL ANALYSIS to %d: %v", chat.ID, err)
		} else {
			log.Printf("‚úÖ [TELEGRAM] Analysis sent to %d (MsgID: %d)", chat.ID, msg.ID)
		}
	}


	// === Helper: Interactive Callbacks ===
	b.Handle(&tele.InlineButton{Unique: "disclaimer_btn"}, func(c tele.Context) error {
		return c.Respond(&tele.CallbackResponse{
			Text:      "‚ö†Ô∏è DISCLAIMER: Sinyal ini dihasilkan oleh AI (Artificial Intelligence). Tidak ada jaminan profit 100%. Gunakan money management yang bijak. Do Your Own Research (DYOR).",
			ShowAlert: true,
		})
	})



	// === Photo Handler (with Album Support) ===
	b.Handle(tele.OnPhoto, func(c tele.Context) error {
		photo := c.Message().Photo
		caption := c.Message().Caption
		
		// If caption is a command, switch mode immediately (optional UX improvement)
		if strings.HasPrefix(caption, "/scalping") {
			userMode.Store(c.Sender().ID, ModeScalping)
		} else if strings.HasPrefix(caption, "/analyst") {
			userMode.Store(c.Sender().ID, ModeStandard)
		}

		// Download Photo
		rc, err := b.File(&photo.File)
		if err != nil {
			return err
		}
		imgData, err := io.ReadAll(rc)
		rc.Close()
		if err != nil {
			return err
		}

		mediaGroupID := c.Message().AlbumID
		userID := c.Sender().ID

		// CASE A: Single Photo (No Media Group)
		if mediaGroupID == "" {
			// Require caption for single photo usually, or use previous context?
			// Let's enforce caption if possible, or default to "Analysis".
			finalCaption := caption
			if finalCaption == "" {
				return c.Send("‚õîÔ∏è Please write the Asset Name in the caption.")
			}
			
			go processAnalysis(userID, finalCaption, [][]byte{imgData}, c.Chat())
			return nil
		}

		// CASE B: Album (Batched)
		// Logic: Store in map, reset timer. If timer hits, process.
		
		actualData, _ := albumBuffer.LoadOrStore(mediaGroupID, &AlbumData{
			UserID: userID,
			Photos: [][]byte{},
			Timer:  nil,
		})
		data := actualData.(*AlbumData)

		// Append photo
		data.Photos = append(data.Photos, imgData)
		
		// Take the caption from the first message that has it
		if caption != "" && data.Caption == "" {
			data.Caption = caption
		}

		// Reset Timer
		if data.Timer != nil {
			data.Timer.Stop()
		}
		
		// Wait 2 seconds for other photos
		data.Timer = time.AfterFunc(2*time.Second, func() {
			// Clean up map
			albumBuffer.Delete(mediaGroupID)
			
			// Validate Caption
			if data.Caption == "" {
				b.Send(c.Chat(), "‚ö†Ô∏è Album received but NO CAPTION found. Processing as 'General Market Analysis'...")
				data.Caption = "Market Analysis"
			}
			
			// Process
			// Sort/Order? Telegram usually delivers in order, but not guaranteed.
			// Vision model is generally robust enough to figure out HTF vs LTF contextually or we prompt it.
			processAnalysis(data.UserID, data.Caption, data.Photos, c.Chat())
		})

		return nil
	})

	fmt.Println("üöÄ Antigravity Bot (Multi-Mode) Started...")
	b.Start()
}