package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net/url"
	"os"
	
	"strings"
	"sync"
	"time"

	"github.com/joho/godotenv"
	"google.golang.org/genai"
	tele "gopkg.in/telebot.v3"
)

// === Enums & State ===
type AnalysisMode int

const (
	ModeStandard AnalysisMode = iota // /analyst
	ModeScalping                     // /analyst-scalping
)

var (
	// userMode stores the user's selected mode
	userMode sync.Map // map[int64]AnalysisMode
	
	// albumBuffer stores photos from a media group
	// map[string]*AlbumData (key: MediaGroupID)
	albumBuffer sync.Map
)

type AlbumData struct {
	CapturedAt time.Time
	Photos     [][]byte
	Caption    string
	UserID     int64
	Timer      *time.Timer
}

// === Prompts ===

func GeneratePrompt(mode AnalysisMode, assetName string, isMultiImage bool) string {
	baseRole := ""
	strategy := ""

	// 1. Determine Mdoe
	switch mode {
	case ModeScalping:
		baseRole = `ROLE: Kamu adalah "Antigravity Scalper", trader agresif spesialis timeframe kecil (M1, M5, M15). Kamu mencari momentum cepat, liquidity grabs, dan rejection tajam.`
		strategy = `METODE SCALPING (FAST EXECUTION):
- Fokus cari: Liquidity Sweep (Pengambilan Stoploss retail) lalu Reversal.
- Rejection Candle Wajib Jelas (Pinbar/Engulfing).
- Risk Reward Ratio minimal 1:2.
- Stoploss harus KETAT (Tight).`

	default: // ModeStandard
		baseRole = `ROLE: Kamu adalah "Antigravity Quant Analyst", AI trading swing/intraday yang mencari setup High Probability (Win Rate > 80%). Kamu sabar dan hanya ambil setup A+.`
		strategy = `METODE STANDARD (SWING/INTRADAY):
- Gunakan Smart Money Concept (SMC) + Supply Demand.
- Validasi Market Structure (BOS/ChoCh).
- Cari konfirmasi Divergence atau Pola Chart Pattern.`
	}

	// 2. Multi-Image Context (Top Down)
	multiContext := ""
	if isMultiImage {
		multiContext = `
[MULTIPLE CHARTS DETECTED - TOP DOWN ANALYSIS MODE]
User mengirimkan LEBIH DARI 1 GAMBAR. Ini adalah analisa Multi-Timeframe.
1. Analisa gambar Timeframe BESAR dulu untuk Trend Bias (Bullish/Bearish).
2. Analisa gambar Timeframe KECIL untuk mencari Entry Point presisi.
3. Pastikan Bias HTF dan LTF sejalan (Confluence). Jika bertabrakan, pilih "NO TRADE".`
	}



	// 3. Construct Full Prompt (Visual Enhancement)
	return fmt.Sprintf(`
%s

CONTEXT:
User mengirimkan chart trading.
Nama Aset: %s
%s

TUGAS EKSEKUSI:

LANGKAH 0: IMAGE CLARITY CHECK üîç
- Periksa visual chart. JIKA BURAM / TIDAK TERBACA: HENTIKAN ANALISA.
- Output: "‚ö†Ô∏è <b>GAMBAR TIDAK JELAS</b>"

LANGKAH 1: EXTERNAL DATA VALIDATION
- Cari sentimen pasar %s hari ini.

LANGKAH 2: VISUAL ANALYSIS
%s
--------------------------------------------------------
CRITICAL RULE:
1. GUNAKAN FORMAT HTML (Telegram Compatible).
2. Escape karakter < > & di dalam teks biasa.
3. GUNAKAN Code Block "diff" untuk warna merah/hijau.
--------------------------------------------------------

OUTPUT FORMAT (STRICT HTML):


<b>üõ∏ ANTIGRAVITY PRIME</b>
<code>%s</code> ‚Ä¢ <code>%s</code>

<b>‚öôÔ∏è STRATEGY MODE: %s</b>

<blockquote>üí° <i>"Quote insight singkat tentang setup ini."</i></blockquote>

<b>üìä SMART DATA</b>
Sentiment: <b>[BULLISH/BEARISH]</b>
Volatilitas: [Low/Med/High]

<b>üíé SIGNAL CARD</b>
<pre><code class="language-diff">
[Gunakan tanda + untuk HIJAU (Buy/TP/Positif)]
[Gunakan tanda - untuk MERAH (Sell/SL/Negatif)]
[Contoh format:]
+ ACTION:  BUY NOW
+ ENTRY:   2030.50
- SL:      2025.00
+ TP 1:    2035.00
+ TP 2:    2040.00
</code></pre>

<b>üìù ANALYSIS BRIEF</b>
(Jelaskan alasan teknikal & fundamental secara padat.)

<b>‚ö†Ô∏è RISK NOTES</b>
(Saran risk management.)

---
<i>Generated by Antigravity AI</i>
	`, baseRole, assetName, multiContext, assetName, strategy, getModeName(mode), assetName, getModeName(mode))
}

func getModeName(m AnalysisMode) string {
	if m == ModeScalping {
		return "SCALPING CAFE"
	}
	return "STANDARD LABS"
}

func main() {
	// Load .env
	_ = godotenv.Load()

	// 1. Init Bot
	pref := tele.Settings{
		Token:  os.Getenv("TELEGRAM_BOT_TOKEN"),
		Poller: &tele.LongPoller{Timeout: 10 * time.Second},
	}

	b, err := tele.NewBot(pref)
	if err != nil {
		log.Fatal(err)
	}

	// 2. Init Gemini
	ctx := context.Background()
	client, err := genai.NewClient(ctx, &genai.ClientConfig{
		APIKey: os.Getenv("GEMINI_API_KEY"),
	})
	if err != nil {
		log.Fatal(err)
	}

	// === Commands ===
	
	// /analyst - Set standard mode
	b.Handle("/analyst", func(c tele.Context) error {
		userMode.Store(c.Sender().ID, ModeStandard)
		return c.Send("üõ∏ <b>Mode: ANALYST STANDARD ACTIVATED</b>\n\nSilakan kirimkan chart Anda (Single atau Album untuk Top Down Analysis).\nJangan lupa tulis nama aset di caption!", tele.ModeHTML)
	})

	// /analyst-scalping - Set scalping mode
	b.Handle("/scalping", func(c tele.Context) error { // shortened for ease
		userMode.Store(c.Sender().ID, ModeScalping)
		return c.Send("‚ö°Ô∏è <b>Mode: SCALPER ELITE ACTIVATED</b>\n\nKirim chart Timeframe Kecil (M1/M5). Sinyal akan fokus pada entry cepat & tight SL.", tele.ModeHTML)
	})
	// Handle full command name too just in case
	b.Handle("/analyst-scalping", func(c tele.Context) error {
		userMode.Store(c.Sender().ID, ModeScalping)
		return c.Send("‚ö°Ô∏è <b>Mode: SCALPER ELITE ACTIVATED</b>\n\nKirim chart Timeframe Kecil (M1/M5). Sinyal akan fokus pada entry cepat & tight SL.", tele.ModeHTML)
	})

	// /help - Show usage instructions
	helpHandler := func(c tele.Context) error {
		helpText := `ü§ñ <b>ANTIGRAVITY AI BOT</b> ü§ñ
		
Selamat datang! Saya adalah asisten trading AI Anda.

<b>üìö CARA PENGGUNAAN:</b>

1. <b>Pilih Mode Analisa:</b>
   ‚Ä¢ /analyst - <b>Mode Standard</b> (Swing/Intraday). Mencari setup High Probability & SMC.
   ‚Ä¢ /scalping - <b>Mode Scalping</b> (M1/M5). Sinyal cepat, SL ketat, target pendek.

2. <b>Kirim Chart:</b>
   ‚Ä¢ Kirim <b>GAMBAR</b> chart Anda.
   ‚Ä¢ <b>WAJIB</b> tulis nama aset di caption (contoh: "XAUUSD", "BTCUSDT").
   ‚Ä¢ Jika gambar buram, kirim sebagai <b>FILE</b>.

3. <b>Fitur Tambahan:</b>
   ‚Ä¢ <b>Top-Down Analysis</b>: Kirim beberapa gambar sekaligus (Album). Bot akan menganalisa dari Timeframe besar ke kecil.

<b>üöÄ Mulai sekarang dengan memilih mode di atas!</b>`
		return c.Send(helpText, tele.ModeHTML)
	}
	
	b.Handle("/help", helpHandler)
	b.Handle("/start", helpHandler)


	// === Helper: Process Logic ===
	processAnalysis := func(userID int64, caption string, images [][]byte, chat *tele.Chat) {
		// 1. Determine Mode
		mode := ModeStandard
		if val, ok := userMode.Load(userID); ok {
			mode = val.(AnalysisMode)
		}

		// 2. Default Caption Check
		targetAsset := caption
		if targetAsset == "" {
			targetAsset = "Unknown Asset"
			// Try to infer from "analyst XAUUSD" pattern if user typed command in caption previously?
			// For now require caption.
		}


		// 3. Status Update
		strategyName := getModeName(mode)
		statusText := fmt.Sprintf("‚è≥ <i>Processing Single Chart...</i>\n‚öôÔ∏è <b>Strategy: %s</b>", strategyName)
		if len(images) > 1 {
			statusText = fmt.Sprintf("‚è≥ <i>Processing Top-Down Analysis (%d Charts)...</i>\n‚öôÔ∏è <b>Strategy: %s</b>", len(images), strategyName)
		}
		statusMsg, err := b.Send(chat, statusText, tele.ModeHTML)

		if err != nil {
			log.Printf("‚ùå [TELEGRAM] Failed to send STATUS to %d: %v", chat.ID, err)
		} else {
			log.Printf("‚úÖ [TELEGRAM] Status sent to %d", chat.ID)
		}

		// 4. Prepare Gemini Parts
		parts := []*genai.Part{}
		
		// Add Prompt first
		prompt := GeneratePrompt(mode, targetAsset, len(images) > 1)
		parts = append(parts, genai.NewPartFromText(prompt))

		// Add All Images
		for _, img := range images {
			parts = append(parts, genai.NewPartFromBytes(img, "image/jpeg"))
		}

		// 5. Build Request
		contents := []*genai.Content{{Parts: parts, Role: "user"}}
		
		// Tools
		tools := []*genai.Tool{{GoogleSearch: &genai.GoogleSearch{}}}
		
		config := &genai.GenerateContentConfig{
			Tools: tools,
		}

		// 6. Call Gemini
		// Using gemini-flash-latest for quota safety
		resp, err := client.Models.GenerateContent(ctx, "gemini-flash-latest", contents, config)
		
		if statusMsg != nil {
			b.Delete(statusMsg)
		}

		if err != nil {
			log.Printf("‚ùå [GEMINI] API Error: %v", err)
			_, errSend := b.Send(chat, "‚ö†Ô∏è <b>Error analyzing</b> (Quota or API Issue). Try again later.", tele.ModeHTML)
			if errSend != nil {
				log.Printf("‚ùå [TELEGRAM] Failed to send ERROR notification to %d: %v", chat.ID, errSend)
			}
			return
		}

		if resp == nil || len(resp.Candidates) == 0 {
			_, errSend := b.Send(chat, "‚ö†Ô∏è No response from AI.", tele.ModeHTML)
			if errSend != nil {
				log.Printf("‚ùå [TELEGRAM] Failed to send NO RESPONSE notification to %d: %v", chat.ID, errSend)
			}
			return
		}

		// 7. Send Result
		responseText := ""
		for _, part := range resp.Candidates[0].Content.Parts {
			responseText += part.Text
		}
		
		// Clean / Fix Gemini MD output to valid HTML
		responseText = cleanHTML(responseText)

		msg, err := b.Send(chat, responseText, &tele.SendOptions{
			ParseMode: tele.ModeHTML,
			ReplyMarkup: &tele.ReplyMarkup{
				InlineKeyboard: [][]tele.InlineButton{
					{
						{
							Text: "üìà TradingView",
							URL:  fmt.Sprintf("https://www.tradingview.com/chart/?symbol=%s", strings.ToUpper(strings.ReplaceAll(targetAsset, " ", ""))),
						},
						{
							Text: "üì∞ News",
							URL:  fmt.Sprintf("https://www.google.com/search?q=%s+news", url.QueryEscape(targetAsset)),
						},
					},
					{
						{
							Text:   "‚ö†Ô∏è Disclaimer",
							Unique: "disclaimer_btn",
						},
					},
				},
			},
		})
		if err != nil {
			log.Printf("‚ùå [TELEGRAM] Failed to send FINAL ANALYSIS to %d: %v", chat.ID, err)
		} else {
			log.Printf("‚úÖ [TELEGRAM] Analysis sent to %d (MsgID: %d)", chat.ID, msg.ID)
		}
	}


	// === Helper: Interactive Callbacks ===
	b.Handle(&tele.InlineButton{Unique: "disclaimer_btn"}, func(c tele.Context) error {
		return c.Respond(&tele.CallbackResponse{
			Text:      "‚ö†Ô∏è DISCLAIMER: Sinyal ini dihasilkan oleh AI (Artificial Intelligence). Tidak ada jaminan profit 100%. Gunakan money management yang bijak. Do Your Own Research (DYOR).",
			ShowAlert: true,
		})
	})



	// === Photo Handler (with Album Support) ===
	b.Handle(tele.OnPhoto, func(c tele.Context) error {
		photo := c.Message().Photo
		caption := c.Message().Caption
		
		// If caption is a command, switch mode immediately (optional UX improvement)
		if strings.HasPrefix(caption, "/scalping") {
			userMode.Store(c.Sender().ID, ModeScalping)
		} else if strings.HasPrefix(caption, "/analyst") {
			userMode.Store(c.Sender().ID, ModeStandard)
		}

		// Download Photo
		rc, err := b.File(&photo.File)
		if err != nil {
			return err
		}
		imgData, err := io.ReadAll(rc)
		rc.Close()
		if err != nil {
			return err
		}

		mediaGroupID := c.Message().AlbumID
		userID := c.Sender().ID

		// CASE A: Single Photo (No Media Group)
		if mediaGroupID == "" {
			// Require caption for single photo usually, or use previous context?
			// Let's enforce caption if possible, or default to "Analysis".
			finalCaption := caption
			if finalCaption == "" {
				return c.Send("‚õîÔ∏è Please write the Asset Name in the caption.")
			}
			
			go processAnalysis(userID, finalCaption, [][]byte{imgData}, c.Chat())
			return nil
		}

		// CASE B: Album (Batched)
		// Logic: Store in map, reset timer. If timer hits, process.
		
		actualData, _ := albumBuffer.LoadOrStore(mediaGroupID, &AlbumData{
			UserID: userID,
			Photos: [][]byte{},
			Timer:  nil,
		})
		data := actualData.(*AlbumData)

		// Append photo
		data.Photos = append(data.Photos, imgData)
		
		// Take the caption from the first message that has it
		if caption != "" && data.Caption == "" {
			data.Caption = caption
		}

		// Reset Timer
		if data.Timer != nil {
			data.Timer.Stop()
		}
		
		// Wait 2 seconds for other photos
		data.Timer = time.AfterFunc(2*time.Second, func() {
			// Clean up map
			albumBuffer.Delete(mediaGroupID)
			
			// Validate Caption
			if data.Caption == "" {
				b.Send(c.Chat(), "‚ö†Ô∏è Album received but NO CAPTION found. Processing as 'General Market Analysis'...")
				data.Caption = "Market Analysis"
			}
			
			// Process
			// Sort/Order? Telegram usually delivers in order, but not guaranteed.
			// Vision model is generally robust enough to figure out HTF vs LTF contextually or we prompt it.
			processAnalysis(data.UserID, data.Caption, data.Photos, c.Chat())
		})

		return nil
	})

	fmt.Println("üöÄ Antigravity Bot (Multi-Mode) Started...")
	b.Start()
}

func cleanHTML(text string) string {
	// 1. Convert Markdown Bold (**text**) to HTML Bold (<b>text</b>)
	countBold := strings.Count(text, "**")
	if countBold > 0 && countBold%2 == 0 {
		for i := 0; i < countBold/2; i++ {
			text = strings.Replace(text, "**", "<b>", 1)
			text = strings.Replace(text, "**", "</b>", 1)
		}
	} else {
		text = strings.ReplaceAll(text, "**", "")
	}
	
	// 2. Convert Markdown Italic (*text*) to HTML Italic (<i>text</i>)
	// Note: This is simpler/riskier but generally safe for Gemini output.
	countItalic := strings.Count(text, "*")
	if countItalic > 0 && countItalic%2 == 0 {
		for i := 0; i < countItalic/2; i++ {
			text = strings.Replace(text, "*", "<i>", 1)
			text = strings.Replace(text, "*", "</i>", 1)
		}
	}

	// 3. Escape standalone '&' which breaks Telegram HTML
	text = strings.ReplaceAll(text, " & ", " &amp; ")

	return text
}